<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>KSSLSocketImpl.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">knio-core</a> &gt; <a href="index.source.html" class="el_package">org.knio.core.net.ssl</a> &gt; <span class="el_source">KSSLSocketImpl.kt</span></div><h1>KSSLSocketImpl.kt</h1><pre class="source lang-java linenums">package org.knio.core.net.ssl

import kotlinx.coroutines.delay
import kotlinx.coroutines.sync.Mutex
import kotlinx.coroutines.sync.withLock
import org.knio.core.nio.readSuspend
import org.knio.core.nio.writeSuspend
import org.knio.core.utils.compactOrIncreaseSize
import org.knio.core.context.KnioContext
import org.knio.core.io.KInputStream
import org.knio.core.io.KOutputStream
import java.io.IOException
import java.net.SocketException
import java.nio.ByteBuffer
import java.nio.channels.AsynchronousSocketChannel
import java.nio.channels.ClosedChannelException
import javax.net.ssl.*
import kotlin.math.min

<span class="fc" id="L20">internal class KSSLSocketImpl (</span>
    channel: AsynchronousSocketChannel,
    sslEngine: SSLEngine,
    useClientMode: Boolean,
<span class="fc" id="L24">    private val context: KnioContext</span>
<span class="fc" id="L25">): KSSLSocketAbstract(</span>
<span class="fc" id="L26">    channel,</span>
<span class="fc" id="L27">    sslEngine,</span>
<span class="fc" id="L28">    useClientMode</span>
) {

<span class="fc" id="L31">    private var handshakeMutex: Mutex = Mutex()</span>
    private var isHandshakeCompleted = false

    private var isInputShutdown = false
    private var networkRead: ByteBuffer?
    private var applicationRead: ByteBuffer?

    private var isOutputShutdown = false
    private var networkWrite: ByteBuffer?

<span class="fc" id="L41">    init {</span>
<span class="fc" id="L42">        networkRead = context.byteBufferPool.acquire(sslEngine.session.packetBufferSize)</span>
<span class="fc" id="L43">        networkWrite = context.byteBufferPool.acquire(sslEngine.session.packetBufferSize)</span>
<span class="fc" id="L44">        applicationRead = context.byteBufferPool.acquire(sslEngine.session.applicationBufferSize).flip()</span>
<span class="fc" id="L45">    }</span>

<span class="fc" id="L47">    private val inputStream = object : KInputStream(context) {</span>

        override suspend fun read(b: ByteBuffer): Int {
<span class="fc" id="L50">            return this@KSSLSocketImpl.read(b)</span>
        }

        override suspend fun close() {
<span class="fc" id="L54">            this@KSSLSocketImpl.close()</span>
<span class="fc" id="L55">        }</span>
    }

<span class="fc" id="L58">    private val outputStream = object : KOutputStream() {</span>

        override suspend fun write(b: ByteBuffer) {
<span class="fc" id="L61">            this@KSSLSocketImpl.write(b)</span>
<span class="fc" id="L62">        }</span>

        override suspend fun close() {
<span class="fc" id="L65">            this@KSSLSocketImpl.close()</span>
<span class="fc" id="L66">        }</span>
    }

    override suspend fun getInputStream(): KInputStream {
<span class="fc bfc" id="L70" title="All 2 branches covered.">        if(!ch.isOpen) {</span>
<span class="fc" id="L71">            throw SocketException(&quot;Socket is closed&quot;)</span>
        }
<span class="fc bfc" id="L73" title="All 2 branches covered.">        if(isInputShutdown()) {</span>
<span class="fc" id="L74">            throw SocketException(&quot;Socket input is shutdown&quot;)</span>
        }
<span class="fc" id="L76">        return inputStream</span>
    }
    override suspend fun getOutputStream(): KOutputStream {
<span class="fc bfc" id="L79" title="All 2 branches covered.">        if(isOutputShutdown()) {</span>
<span class="fc" id="L80">            throw SocketException(&quot;Socket output is shutdown&quot;)</span>
        }
<span class="fc" id="L82">        return outputStream</span>
    }

    /**
     * Starts the handshake process.
     */
<span class="fc" id="L88">    override suspend fun doHandshake() = handshakeMutex.withLock {</span>
        // lock to prevent multiple handshakes
<span class="fc" id="L90">        doHandshake0()</span>
<span class="fc" id="L91">    }</span>

    /**
     * The non-locked logic for starting the handshake.
     */
    private suspend fun doHandshake0() {
        // Note: ONLY `doHandshake` should call this method. Use `startHandshake`
        // to start the handshake.

<span class="fc bfc" id="L100" title="All 2 branches covered.">        if(isHandshakeCompleted) return</span>

        @Suppress(&quot;BlockingMethodInNonBlockingContext&quot;)
<span class="fc" id="L103">        sslEngine.beginHandshake()</span>

<span class="fc" id="L105">        networkRead!!.clear().flip()</span>
<span class="fc" id="L106">        networkWrite!!.clear()</span>

<span class="fc bfc" id="L108" title="All 2 branches covered.">        while (sslEngine.isHandshaking) {</span>
<span class="pc bpc" id="L109" title="1 of 4 branches missed.">            when(sslEngine.handshakeStatus!!) {</span>
                SSLEngineResult.HandshakeStatus.NEED_TASK -&gt; {
<span class="fc" id="L111">                    runHandshakeTasks()</span>
                }
                SSLEngineResult.HandshakeStatus.NEED_WRAP -&gt; {
                    @Suppress(&quot;BlockingMethodInNonBlockingContext&quot;)
<span class="fc" id="L115">                    wrapHandshake()</span>
                }
                SSLEngineResult.HandshakeStatus.NEED_UNWRAP,
                SSLEngineResult.HandshakeStatus.NEED_UNWRAP_AGAIN-&gt; {
                    @Suppress(&quot;BlockingMethodInNonBlockingContext&quot;)
<span class="fc" id="L120">                    unwrapHandshake()</span>
                }
                SSLEngineResult.HandshakeStatus.FINISHED,
                SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING -&gt; {
                    // DONE!
<span class="nc" id="L125">                    continue</span>
                }
            }
        }

        // clear buffers
        //networkRead?.clear()
<span class="pc bpc" id="L132" title="1 of 2 branches missed.">        networkWrite?.clear()</span>
<span class="pc bpc" id="L133" title="2 of 4 branches missed.">        applicationRead?.clear()?.flip()</span>
        //applicationWrite?.clear()

<span class="fc" id="L136">        isHandshakeCompleted = true</span>
<span class="fc" id="L137">    }</span>

    private fun runHandshakeTasks() {
<span class="fc" id="L140">        while (true) {</span>
<span class="fc bfc" id="L141" title="All 2 branches covered.">            val task = sslEngine.delegatedTask ?: break</span>
<span class="fc" id="L142">            task.run()</span>
        }
<span class="fc" id="L144">    }</span>

    private suspend fun wrapHandshake() {
<span class="fc" id="L147">        val dummyBuffer = ByteBuffer.allocate(0)</span>

<span class="fc" id="L149">        while (true) {</span>
<span class="fc" id="L150">            networkWrite!!.clear()</span>

<span class="fc" id="L152">            @Suppress(&quot;BlockingMethodInNonBlockingContext&quot;)</span>
<span class="fc" id="L153">            val result = sslEngine.wrap(dummyBuffer, networkWrite)</span>

<span class="pc bpc" id="L155" title="3 of 4 branches missed.">            when (result.status!!) {</span>
                SSLEngineResult.Status.BUFFER_UNDERFLOW -&gt; {
                    //
<span class="nc" id="L158">                    throw SSLException(&quot;Buffer underflow while wrapping in handshake&quot;)</span>
                }

                SSLEngineResult.Status.BUFFER_OVERFLOW -&gt; {
                    // Increase network buffer size. This shouldn't typically happen during handshake.
                    // The network buffer is clear and the size should be the same as the packet buffer size.
<span class="nc" id="L164">                    networkWrite = networkWrite!!.compactOrIncreaseSize(</span>
<span class="nc" id="L165">                        sslEngine.session.packetBufferSize,</span>
<span class="nc" id="L166">                        context.byteBufferPool</span>
                    )
                }

                SSLEngineResult.Status.OK -&gt; {
                    // Unwrap was successful. Write the data to the channel.
<span class="fc" id="L172">                    networkWrite!!.flip()</span>
<span class="fc bfc" id="L173" title="All 2 branches covered.">                    while (networkWrite!!.hasRemaining()) {</span>
<span class="fc" id="L174">                        val read = ch.writeSuspend(networkWrite!!, getWriteTimeout())</span>
<span class="pc bpc" id="L175" title="1 of 2 branches missed.">                        if (read == -1) {</span>
<span class="nc" id="L176">                            throw SSLException(&quot;Connection closed during handshake&quot;)</span>
                        }
<span class="pc bpc" id="L178" title="1 of 2 branches missed.">                        if (read == 0) {</span>
                            // TODO
<span class="nc" id="L180">                            throw SSLException(&quot;?? no data written during handshake. try again or error ??&quot;)</span>
                        }
                    }
<span class="fc" id="L183">                    break</span>
                }

                SSLEngineResult.Status.CLOSED -&gt; {
                    // closed
<span class="nc" id="L188">                    throw SSLException(&quot;Connection closed during handshake&quot;)</span>
                }
            }
        }
<span class="fc" id="L192">    }</span>

    private suspend fun unwrapHandshake() {
<span class="fc" id="L195">        val dummyBuffer = ByteBuffer.allocate(0)</span>

<span class="fc" id="L197">        while (true) {</span>
            // try to unwrap data from the network buffer
<span class="fc" id="L199">            @Suppress(&quot;BlockingMethodInNonBlockingContext&quot;)</span>
<span class="fc" id="L200">            val result = sslEngine.unwrap(networkRead, dummyBuffer)</span>

<span class="pc bpc" id="L202" title="2 of 4 branches missed.">            when (result.status!!) {</span>
                SSLEngineResult.Status.BUFFER_UNDERFLOW -&gt; {
                    // An underflow implies there wasn't enough information in the network buffer to unwrap

                    // increase the available network buffer size
<span class="fc" id="L207">                    networkRead = networkRead!!.compactOrIncreaseSize(</span>
<span class="fc" id="L208">                        sslEngine.session.packetBufferSize,</span>
<span class="fc" id="L209">                        context.byteBufferPool</span>
                    )

                    // read more data from the channel
<span class="fc" id="L213">                    val count = ch.readSuspend(networkRead!!)</span>
<span class="fc bfc" id="L214" title="All 2 branches covered.">                    if(count == -1) {</span>
<span class="fc" id="L215">                        throw SSLException(&quot;Connection closed during handshake&quot;)</span>
                    }
<span class="pc bpc" id="L217" title="1 of 2 branches missed.">                    if(count == 0) {</span>
                        // TODO
<span class="nc" id="L219">                        throw SSLException(&quot;?? no data read during handshake. try again or error ??&quot;)</span>
                    }

                    // flip the buffer to prepare for unwrapping
<span class="fc" id="L223">                    networkRead!!.flip()</span>
                }

                SSLEngineResult.Status.BUFFER_OVERFLOW -&gt; {
                    // shouldn't happen during handshake
<span class="nc" id="L228">                    throw SSLException(&quot;Buffer underflow while unwrapping in handshake&quot;)</span>
                }

                SSLEngineResult.Status.OK -&gt; {
                    // unwrap was successful. leave the data in the network buffer for the next unwrap
<span class="fc" id="L233">                    break</span>
                }

                SSLEngineResult.Status.CLOSED -&gt; {
                    // closed
<span class="nc" id="L238">                    throw SSLException(&quot;Connection closed during handshake&quot;)</span>
                }
            }
        }
<span class="fc" id="L242">    }</span>

    override suspend fun isInputShutdown(): Boolean {
<span class="fc" id="L245">        return isInputShutdown</span>
    }

    override suspend fun isOutputShutdown(): Boolean {
<span class="fc" id="L249">        return isOutputShutdown</span>
    }

    override suspend fun shutdownInput() {
<span class="fc bfc" id="L253" title="All 2 branches covered.">        val netBuff = networkRead ?: return</span>
<span class="fc" id="L254">        networkRead = null</span>

<span class="fc" id="L256">        try {</span>
<span class="fc" id="L257">            try {</span>
                @Suppress(&quot;BlockingMethodInNonBlockingContext&quot;)
<span class="fc" id="L259">                sslEngine.closeInbound()</span>
<span class="fc" id="L260">            } catch (e: SSLException) {</span>
                // ignore
            }

            // Clear buffer for reuse or release
<span class="fc" id="L265">            netBuff.clear()</span>
        } finally {
<span class="fc" id="L267">            isInputShutdown = true</span>
<span class="fc" id="L268">            context.byteBufferPool.release(netBuff)</span>
        }
<span class="fc" id="L270">    }</span>

    override suspend fun shutdownOutput() {
<span class="pc bpc" id="L273" title="1 of 2 branches missed.">        var netBuff = networkWrite ?: return</span>
<span class="fc" id="L274">        networkWrite = null</span>

<span class="fc" id="L276">        try {</span>
<span class="fc" id="L277">            sslEngine.closeOutbound()</span>

<span class="fc" id="L279">            netBuff.clear()</span>
<span class="fc" id="L280">            out@ while (true) {</span>
<span class="fc" id="L281">                @Suppress(&quot;BlockingMethodInNonBlockingContext&quot;)</span>
<span class="fc" id="L282">                val result = sslEngine.wrap(ByteBuffer.allocate(0), netBuff)</span>

<span class="pc bpc" id="L284" title="3 of 4 branches missed.">                when (result.status!!) {</span>

                    SSLEngineResult.Status.BUFFER_OVERFLOW -&gt; {
                        // increase network buffer size
<span class="nc" id="L288">                        netBuff = netBuff.compactOrIncreaseSize(</span>
<span class="nc" id="L289">                            sslEngine.session.packetBufferSize,</span>
<span class="nc" id="L290">                            context.byteBufferPool</span>
                        )
                    }

                    SSLEngineResult.Status.OK -&gt; {
<span class="nc" id="L295">                        try {</span>
<span class="nc" id="L296">                            netBuff.flip()</span>
<span class="nc bnc" id="L297" title="All 2 branches missed.">                            while (netBuff.hasRemaining()) {</span>
<span class="nc" id="L298">                                var written = 0;</span>
<span class="nc bnc" id="L299" title="All 2 branches missed.">                                repeat(3) { attempt -&gt;</span>
<span class="nc" id="L300">                                    written = ch.writeSuspend(netBuff)</span>
<span class="nc bnc" id="L301" title="All 2 branches missed.">                                    if (written &gt; 0) return@repeat</span>
<span class="nc" id="L302">                                    delay(100L * attempt) // Backoff delay</span>
<span class="nc" id="L303">                                }</span>

<span class="nc bnc" id="L305" title="All 2 branches missed.">                                if (written &lt;= 0) {</span>
<span class="nc" id="L306">                                    break@out</span>
                                }
                            }
<span class="nc" id="L309">                            netBuff.clear()</span>
<span class="nc" id="L310">                            break</span>
<span class="nc" id="L311">                        } catch (e: ClosedChannelException) {</span>
                            // ignore
<span class="nc" id="L313">                        } catch (e: IOException) {</span>
<span class="nc" id="L314">                            throw e</span>
                        }
                    }

                    SSLEngineResult.Status.CLOSED -&gt; {
                        // closed
<span class="fc" id="L320">                        break@out</span>
                    }

                    else -&gt; {
<span class="nc" id="L324">                        throw SSLException(&quot;Unexpected SSL wrap status: ${result.status}&quot;)</span>
                    }
                }
            }

<span class="fc" id="L329">            try {</span>
                @Suppress(&quot;BlockingMethodInNonBlockingContext&quot;)
<span class="fc" id="L331">                ch.shutdownOutput()</span>
<span class="nc" id="L332">            } catch (e: ClosedChannelException) {</span>
                // ignore
<span class="nc" id="L334">            } catch (e: IOException) {</span>
<span class="nc" id="L335">                throw e</span>
            }
        } finally {
<span class="fc" id="L338">            isOutputShutdown = true</span>
<span class="fc" id="L339">            context.byteBufferPool.release(netBuff)</span>
        }
<span class="fc" id="L341">    }</span>

    private suspend fun read(b: ByteBuffer): Int {
<span class="pc bpc" id="L344" title="1 of 8 branches missed.">        if(isInputShutdown &amp;&amp; applicationRead?.hasRemaining() == false) {</span>
<span class="fc" id="L345">            return -1</span>
        }

<span class="pc bpc" id="L348" title="1 of 4 branches missed.">        if(!isHandshakeCompleted &amp;&amp; isInputShutdown) {</span>
<span class="nc" id="L349">            return -1</span>
        }

<span class="fc bfc" id="L352" title="All 2 branches covered.">        if(!isHandshakeCompleted) {</span>
<span class="pc bpc" id="L353" title="1 of 2 branches missed.">            applicationRead?.clear()</span>
<span class="fc" id="L354">            startHandshake()</span>
        }

<span class="pc bpc" id="L357" title="1 of 2 branches missed.">        var app = this@KSSLSocketImpl.applicationRead ?: return -1</span>
<span class="fc bfc" id="L358" title="All 2 branches covered.">        var net = this@KSSLSocketImpl.networkRead ?: return -1</span>

<span class="fc" id="L360">        val start = b.position()</span>

<span class="pc bpc" id="L362" title="1 of 2 branches missed.">        input@ while(b.hasRemaining()) {</span>
<span class="fc bfc" id="L363" title="All 2 branches covered.">            if(app.hasRemaining()) {</span>
<span class="fc" id="L364">                val count = min(app.remaining(), b.remaining())</span>
<span class="fc" id="L365">                b.put(b.position(), app, app.position(), count)</span>

<span class="fc" id="L367">                app.position(app.position() + count)</span>
<span class="fc" id="L368">                b.position(b.position() + count)</span>

<span class="fc" id="L370">                continue</span>
            }

<span class="fc bfc" id="L373" title="All 2 branches covered.">            if(net.hasRemaining()) {</span>
<span class="fc" id="L374">                app.clear()</span>
<span class="fc" id="L375">                while(true) {</span>

<span class="fc" id="L377">                    @Suppress(&quot;BlockingMethodInNonBlockingContext&quot;)</span>
<span class="fc" id="L378">                    val result = sslEngine.unwrap(net, app)</span>
<span class="pc bpc" id="L379" title="2 of 4 branches missed.">                    when (result.status!!) {</span>
                        SSLEngineResult.Status.BUFFER_UNDERFLOW -&gt; {
<span class="nc" id="L381">                            networkRead = net.compactOrIncreaseSize(sslEngine.session.packetBufferSize, context.byteBufferPool)</span>
<span class="nc" id="L382">                            net = networkRead!!</span>
                        }
                        SSLEngineResult.Status.BUFFER_OVERFLOW -&gt; {
<span class="nc" id="L385">                            applicationRead = app.compactOrIncreaseSize(sslEngine.session.applicationBufferSize, context.byteBufferPool)</span>
<span class="nc" id="L386">                            app = applicationRead!!</span>
                        }
                        SSLEngineResult.Status.OK -&gt; {
<span class="fc" id="L389">                            app.flip()</span>
<span class="fc" id="L390">                            break</span>
                        }
                        SSLEngineResult.Status.CLOSED -&gt; {
<span class="fc" id="L393">                            shutdownInput()</span>
<span class="fc" id="L394">                            break@input</span>
                        }
                    }
                }
            } else {
<span class="fc" id="L399">                net.clear()</span>
<span class="fc" id="L400">                val count = ch.readSuspend(net, getReadTimeout())</span>
<span class="fc bfc" id="L401" title="All 2 branches covered.">                if(count == -1) {</span>
<span class="fc" id="L402">                    shutdownInput()</span>
<span class="fc" id="L403">                    break@input</span>
                }
<span class="pc bpc" id="L405" title="1 of 2 branches missed.">                if (count == 0) {</span>
                    // return if no data read
<span class="nc" id="L407">                    break@input</span>
                }
<span class="fc" id="L409">                net.flip()</span>
            }
        }

<span class="fc bfc" id="L413" title="All 2 branches covered.">        return if(b.position() == start) {</span>
<span class="pc bpc" id="L414" title="1 of 2 branches missed.">            if(isInputShutdown) -1 else 0</span>
        } else {
<span class="fc" id="L416">            b.position() - start</span>
        }
    }

    private suspend fun write(b: ByteBuffer) {
<span class="fc bfc" id="L421" title="All 2 branches covered.">        if(!isHandshakeCompleted) {</span>
            @Suppress(&quot;BlockingMethodInNonBlockingContext&quot;)
<span class="fc" id="L423">            startHandshake()</span>
        }

<span class="fc bfc" id="L426" title="All 2 branches covered.">        while(b.hasRemaining()) {</span>
<span class="fc" id="L427">            @Suppress(&quot;BlockingMethodInNonBlockingContext&quot;)</span>
<span class="fc" id="L428">            val result = sslEngine.wrap(b, networkWrite)</span>

<span class="pc bpc" id="L430" title="2 of 4 branches missed.">            when (result.status!!) {</span>
                SSLEngineResult.Status.BUFFER_UNDERFLOW -&gt; {
                    // increase network buffer size
<span class="nc" id="L433">                    throw SSLException(&quot;Buffer underflow while wrapping&quot;)</span>
                }

                SSLEngineResult.Status.BUFFER_OVERFLOW -&gt; {
                    // increase network buffer size
<span class="nc" id="L438">                    networkWrite = networkWrite!!.compactOrIncreaseSize(</span>
<span class="nc" id="L439">                        sslEngine.session.packetBufferSize,</span>
<span class="nc" id="L440">                        context.byteBufferPool</span>
                    )
                }

                SSLEngineResult.Status.OK -&gt; {
<span class="fc" id="L445">                    networkWrite!!.flip()</span>
<span class="fc bfc" id="L446" title="All 2 branches covered.">                    while (networkWrite!!.hasRemaining()) {</span>
<span class="fc" id="L447">                        val written = ch.writeSuspend(networkWrite!!, getWriteTimeout())</span>
<span class="pc bpc" id="L448" title="1 of 2 branches missed.">                        if (written == -1) {</span>
<span class="nc" id="L449">                            throw SSLException(&quot;Connection closed during handshake&quot;)</span>
                        }
<span class="pc bpc" id="L451" title="1 of 2 branches missed.">                        if (written == 0) {</span>
                            // TODO
<span class="nc" id="L453">                            throw SSLException(&quot;?? no data written during handshake. try again or error ??&quot;)</span>
                        }
                    }
<span class="fc" id="L456">                    networkWrite!!.clear()</span>
<span class="fc" id="L457">                    break</span>
                }

                SSLEngineResult.Status.CLOSED -&gt; {
                    // closed
<span class="fc" id="L462">                    throw SocketException(&quot;connection closed&quot;)</span>
                }
            }
        }
<span class="fc" id="L466">    }</span>

    /**
     * Returns true if the SSLEngine is handshaking.
     */
    private val SSLEngine.isHandshaking: Boolean
<span class="pc bpc" id="L472" title="1 of 2 branches missed.">        get() = this.handshakeStatus != SSLEngineResult.HandshakeStatus.FINISHED</span>
<span class="fc bfc" id="L473" title="All 2 branches covered.">                &amp;&amp; this.handshakeStatus != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>